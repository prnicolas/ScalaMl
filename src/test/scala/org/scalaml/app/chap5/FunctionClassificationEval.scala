/**
 * Copyright (c) 2013-2015  Patrick Nicolas - Scala for Machine Learning - All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License") you may not use this file 
 * except in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software is distributed on an 
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * 
 * The source code in this file is provided by the author for the sole purpose of illustrating the 
 * concepts and algorithms presented in "Scala for Machine Learning". 
 * ISBN: 978-1-783355-874-2 Packt Publishing.
 * 
 * Version 0.99
 */
package org.scalaml.app.chap5

	// Scala standard library
import scala.util.{Try, Success, Failure, Random}
import scala.collection._
import org.apache.log4j.Logger

import org.scalaml.stats.XTSeries
import org.scalaml.core.Types.ScalaMl
import org.scalaml.workflow.data.{DataSource,DocumentsSource}
import org.scalaml.filtering.dft.DFT
import org.scalaml.filtering.movaverage.SimpleMovingAverage
import org.scalaml.supervised.bayes.NaiveBayes
import org.scalaml.util.{DisplayUtils, LoggingUtils}
import org.scalaml.app.Eval
import LoggingUtils._

		/**
		 * '''Purpose:''' Singleton to evaluate the Binomial Naive Bayes algorithm to classify
		 * mathematical functions. The two categories of mathematical functions are sinusoidal and 
		 * the rectangular function. The mathematical functions are characterized by the frequency 
		 * spectrum of the time series generated by the functions. The indices of the ordered 
		 * frequencies are used to score the mathematical functions. The frequencies are computed 
		 * using the Discrete Fourier series.
		 * 
		 * @author Patrick Nicolas
		 * @since July 3, 2014
		 * @note Scala for Machine Learning Chapter 5: Naive Bayes Models
		 */
object FunctionClassificationEval extends Eval {
	import ScalaMl._,  SimpleMovingAverage._
	
		/**
		 * Name of the evaluation 
		 */
	val name: String = "NaiveBayesEval"

	type Input = Vector[(DblArray, Int)]
			
	private val DATA_SIZE = 1025
	private val ALPHA = 1e-3
	private val BETA = 1e-2
	private val GAMMA = ALPHA*0.1
	private val SPECTRUM = 24
      		
		/**
		 * Execution of the scalatest for '''NaiveBayes''' class
		 * This method is invoked by the  actor-based test framework function, ScalaMlTest.evaluate
		 * 	
		 * Exceptions thrown during the execution of the tests are caught by the wrapper or handler
		 * test method in Eval trait defined as follows:
		 * {{{
		 *    def test(args: Array[String]) =
		 *      Try(run(args)) match {
		 *        case Success(n) => ...
		 *        case Failure(e) => ...
		 * }}}
		 * The tests can be executed through ''sbt run'' or individually by calling 
		 * ''TestName.test(args)'' (i.e. DKalmanEval.test(Array[String]("IBM") )
		 * @param args array of arguments used in the test
		 */
	override protected def run(args: Array[String]): Int = {
	  import scala.language.postfixOps
	  import XTSeries._
	  
		show(s"$header Function classification using Naive Bayes")	
			/**
			 * Labeled mathematical functions.
			 */
		val functionsGroup = Array[Double => Double] (
			(x: Double) => {
				val a = ALPHA*(0.5 + GAMMA*Random.nextDouble)
				val b = BETA*(0.5 + GAMMA*Random.nextDouble) 
				Math.sin(a*x) + Math.cos(b*x)
			},
			(x: Double) => if( x > 0.48 && x < 0.52) 1.0 else 0.0
		)
	  
		/**
		 * Training set using the labeled mathematical functions
		 */
		def trainingDatasets(numSamples: Int): Input =  
	    Vector.tabulate(numSamples)(n => {
	      val index = Random.nextInt(functionsGroup.size)
				val sets = createDatasets(functionsGroup(index), numSamples)
				(sets, index)    
	    })
	  
	  
		/**
		 * Method to create datasets for training and testing. It normalizes the values, then computes
		 * the frequencies related to the datasets, ranks the data points in decreasing order of their
		 * frequency and return the SPECTUM indices of the data point with the highest frequency.
		 * @param f Transformation of Double floating point values
		 * @param numSamples Number of samples to be used for the Discrete Fourier series
		 * @return normalized vector of frequencies
		 */
		def createDatasets(f: Double => Double, numSamples: Int): DblArray = {
			val values = Range(0, numSamples).map(_ /DATA_SIZE.toDouble).map(f(_)).toVector
			val min = values.min
			val delta = values.max - min
		
			
			val pfnDFT = DFT[Double] |>
			val input = values.map(x =>(x -min)/delta)
			
			pfnDFT(input).map( freq => {
				val freQ = freq.zipWithIndex.sortWith( _._1 > _._1 ).toArray
				freQ.take(SPECTRUM).map( _._2.toDouble/DATA_SIZE)
			})
			.getOrElse(Array.empty[Double])
		}

		/**
		 * Method to generate datasets for testing
		 */
		def testDataset(f: Double =>Double): Vector[DblArray] = 
				createDatasets(f, DATA_SIZE).map(Array[Double](_)).toVector

		/**
		 * Our test functions.
		 */
		val g = (x: Double) => Math.cos(ALPHA*x)
		val h = (x: Double) => if( x >= 0.49 && x <= 0.51) 1.0 else 0.0

		/**
		 * Scoring function. The linear comparison is used instead of the Gaussian 
		 * distribution because the standard deviation is very small and potentially
		 * introduces significant rounding errors
		 */
		def scoring(x: Double*): Double = Math.abs(x(2) - x(0))
      	
		
		val nb = NaiveBayes(1.0, trainingDatasets(3), scoring, 2)
			
			show(s"$header Trained model for function classification ${nb.toString}")
			val result1 = testDataset(g).map( nb |> _).mkString(",")
			show(s"$name Naive Bayes classification for 'cos(ALPHA*x)' classes: $result}")
	
			val result2 = testDataset(h).map( nb |> _).mkString(",")
			show(s"$name Naive Bayes classify for 'if(x ~ 0.5) 1.0 else 0' class: $result2")

	}
}

// -----------------------------  EOF ------------------------------------