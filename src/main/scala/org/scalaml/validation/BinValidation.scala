/**
 * Copyright (c) 2013-2015  Patrick Nicolas - Scala for Machine Learning - All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License") you may not use this file 
 * except in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software is distributed on an 
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * 
 * The source code in this file is provided by the author for the sole purpose of illustrating the 
 * concepts and algorithms presented in "Scala for Machine Learning". 
 * ISBN: 978-1-783355-874-2 Packt Publishing.
 * 
 * Version 0.99
 */
package org.scalaml.validation

import scala.util.Try

import org.scalaml.util.MapUtils.Counter
import org.scalaml.supervised.Supervised
import org.scalaml.core.Types.ScalaMl._

		/**
		 * Enumeration for validation labels such as TP (true positive), TN (true negative)
		 * FP (false positive) and FN (false negative)
		 * @author Patrick Nicolas
		 */
object Label extends Enumeration(0) {
	type Label = Value
	val TP, TN, FP, FN = Value
}



import Label._, BinFValidation._



		/**
		 * Immutable class that implements the metrics to validate a model with two classes 
		 * (or binomial F validation). The validation is applied to a test or validation run
		 * The counters for TP, TN, FP and FN are computed during instantiation
		 * to the class, Accuracy, precision and recall are computed at run-time (lazy values).
		 * {{{
		 *    precision = TP/(TP + FP)
		 *    recall  TP/(TP + FN)
		 *    F1 = 2.precision.recall/(precision + recall)
		 *    F2 = 5.precision.recall/(4.precision + recall)
		 *    Fn = (1+n.n).precision.recall/(n.n.precision + recall)
		 *    G = Sqrt(precision.recall)
		 * }}}
		 * @constructor Create a class validation instance that compute precision, recall and F1 measure 
		 * @throws IllegalArgumentException if actualExpected is undefined or has no elements or 
		 * tpClass is out of range
		 * @param actual Array of label or actual values
		 * @param xt time series or set of observations used for validating the model
		 * @param predict function that predict the class of a new observation. The function is
		 * generated by the classifier.
	
		 * @author Patrick Nicolas
		 * @since 0.98.2 February 1, 2014
		 * @see Scala for Machine Learning Chapter 2 "Hello World!" / Assessing a model / Validation
		 * @see org.scalaml.validation.MultiFValidation
		 * @note The quality metrics are computed for the class of index 1 which is contained
		 * arbitrary the positive outcome. Computation of precision and recall for an entire model is
		 * performed by the class '''MultiFValidation'''
		 */
@throws(classOf[IllegalArgumentException])
final class BinFValidation[T <: AnyVal](
		expected: Vector[Int],
		xt: XVSeries[T])(predict: Array[T] => Int)(implicit f: T => Double) 
	extends FValidation[T](expected, xt)(predict) {


		private[this] val counters: Counter[Label] = {
			val predicted = xt.map( predict(_) )
			
			println(expected.mkString(","))
			println(predicted.mkString(","))
			expected.zip(predicted)./:(new Counter[Label]){ 
				case (cnt, (y, x)) => cnt + classify(x, y) }
		}
		
				/**
				 * Implements the computation of the score of the validation of a classifier for 
				 * the F-measure. By default the score use the F1-score.
				 * @return F1 score of the classification
				 */
		override def score: Double = f1
				
			/**
			 * Compute the F1 measure for this classifier as (precision + recall)/(2.precision.recall)
			 * @return F1 measure using precomputed precision and recall
			 */
	 	lazy val f1: Double = 2.0*precision*recall/(precision + recall)
	 	
	 		/**
	 		 * Compute the Fn measure for this classifier as
	 		 * (1+n*n).precision.recall/(n*n*precision + recall)
	 		 * @param degree of the F measure		 
	 		 * @return Fn measure
	 		 * @throws IllegalArgumentException if the degree of the measure is null or negative
	 		 * @throws IllegalStateException if some of counters are null
	 		 */
	 	@throws(classOf[IllegalArgumentException])
	 	@throws(classOf[IllegalStateException])
	 	def fn(n: Int): Double = {
		  require( n > 0, s"BinFValidation.fn degree of measure or score $n should be > 0")
		  
		  val n2 = n*n
		  (1 + n2)*precision*recall/(n2*precision + recall)
		}
		
		
		 		/**
	 		 * Compute the geometric mean of precision and recall for this classifier as
	 		 * Sqrt(precision.recall)	 
	 		 * @return Geometric mean of precision and recall
	 		 * @throws IllegalStateException if some of counters are null
	 		 */
		@throws(classOf[IllegalStateException])
		def g: Double = Math.sqrt(precision*recall)
	  			    
	 	
			/**
			 * Accuracy of a classifier using TP and TN counters.
			 * @return Accuracy for the model
			 */
		lazy val accuracy: Double = {
			val num = (counters(TP) + counters(TN)).toDouble
			num/counters.aggregate(0)( (s,kv)  => s + kv._2, _ + _)
		}
	
	  	 
			/**
			 * Precision of a classifier using TP and FP counters.
			 * @return Precision for the model if either TP or FP counters is not null
			 * @throws IllegalStateException if some counters are null
			 */
		@throws(classOf[IllegalStateException])
		lazy val precision = compute(FP)
	
	  	 
			/**
			 * Recall of a classifier using TP and FN counters.
			 * @return recall value for the model or classifier
			 * @throws IllegalStateException if some counters are null
			 */
		@throws(classOf[IllegalStateException])
		lazy val recall = compute(FN)
	
	  	 
		private def compute(n: Label): Double = {
			val denom = counters(TP) + counters(n)
			if( denom < 1) 
				throw new IllegalStateException(s"BinFValidation.compute TP = $TP or n =$n should be > 0")
			counters(TP).toDouble/denom
		}
	
	
	private def classify(computed: Int, label: Int): Label = 
		if( computed == label) 
			if( label == POSITIVE) TP else TN
		else 
			if( label== POSITIVE) FN else FP
}


		/**
		 * Companion object to the Class validation class that implement the constructors apply
		 * @author Patrick Nicolas
		 * @since February 1, 2014
		 * @note Scala for Machine Learning Chapter 2 Hello World! / Assessing a model / Validation
		 */
object BinFValidation {
	final val POSITIVE = 1
		/**
		 * Default constructor for the ClassValidation
		 * @param actualExpected Array of pair (actual value, labeled/expected value)
		 * @param tpClass Identifier for the class that defined the true positive samples
		 */
	def apply[T <: AnyVal](
			expected: Vector[Int], 
			xt:  XVSeries[T])(predict: Array[T] => Int)
			(implicit f: T => Double): Try[BinFValidation[T]] = Try {
 		new BinFValidation(expected, xt)(predict)
	}
}


// --------------------  EOF --------------------------------------------------------