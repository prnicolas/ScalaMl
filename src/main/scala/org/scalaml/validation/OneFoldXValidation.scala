/**
 * Copyright (c) 2013-2015  Patrick Nicolas - Scala for Machine Learning - All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License") you may not use this file 
 * except in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software is distributed on an 
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * 
 * The source code in this file is provided by the author for the sole purpose of illustrating the 
 * concepts and algorithms presented in "Scala for Machine Learning". 
 * ISBN: 978-1-783355-874-2 Packt Publishing.
 * 
 * Version 0.99
 */
package org.scalaml.validation

import scala.collection.immutable.VectorBuilder
import scala.util.{Try, Random}
import scala.language.implicitConversions

import org.scalaml.core.Types.ScalaMl.{DblArray, XVSeries}


			/**
		 * Class implementing a 1-Fold crossValidation
		 * @tparam T type of element of data to be processed 
		 * @constructor Create a one fold cross validation scheme to validate supervised
		 * learning algorithm
		 * @param xt Multi-dimensional time series of observations
		 * @param expected expected (or labeled) class
		 * @param ratio Ratio of training/validation 
		 * @throws IllegalArgumentException if the number of values, nValues is out of range 
		 * @author Patrick Nicolas
		 * @since 0.99 (April 3, 2014)
		 * @see Scala for Machine Learning Chapter 2 ''Hello World!'' / Assessing a model / 
		 * K-Fold validation
		 */
@throws(classOf[IllegalArgumentException])
final class OneFoldXValidation[T <: AnyVal](
		xt: XVSeries[T],
		expected: Vector[Int], 
		ratio: Double) {
	import OneFoldXValidation._ 
  
	check(xt, expected, ratio)
  
	private[this] val trainValidate: (ValidationType[T], ValidationType[T]) = { 
		val labeledData = xt.zip(expected)
		val trainingSize = (ratio*labeledData.size).floor.toInt
  
			// Compute the size of the validation set and adjust if necessary
		val valSz = labeledData.size - trainingSize
		val adjValSz = if(valSz < 2) 1 
			else if(valSz >= labeledData.size) labeledData.size -1 
			else valSz

			// The random ordering of the dataset in the training set
			// and validation set are created by assigning a random value
			// to each labeled observations then sort them 
		val ordLabeledData = labeledData.map((_, Random.nextDouble))
							.sortWith( _._2 < _._2).unzip._1

			// Return the pair of training and validation sets.
		(ordLabeledData.takeRight(adjValSz), ordLabeledData.dropRight(adjValSz))
	}

		/**
		 * Return the training set generated by the 1-fold cross validation
		 * @return training set of type ''Vector[(Array[T], Int)]''
		 */
	final def trainingSet: ValidationType[T] = trainValidate._1
	
		/**
		 * Return the validation set generated by the 1-fold cross validation
		 * @return validation set of type ''Vector[(Array[T], Int)]''
		 */
	final def validationSet: ValidationType[T] = trainValidate._2
}


	/**
	 * Object companion to OneFoldXValidation that defines internal type
	 * and constructors.
	 * @author Patrick Nicolas
	 * @version 0.99
	 * @see Scala for Machine Learning Chapter 2 Hello World! / Assessing a model / 
		 * K-Fold validation
	 */
object OneFoldXValidation {
	type LabeledData[T] = (Array[T], Int)
	type LabeledType[T] = (LabeledData[T], Boolean)
	type ValidationType[T] = Vector[(Array[T], Int)]
	
		/**
		 * Constructor for OneFoldXValidation class using the observation, expected values and
		 * the ratio of training set size and validation set size as arguments
		 * @tparam T type of element of data to be processed 
		 * @param xt Time series or data set of observed features of type Vector[Array[T]]
		 * @param expected labels or expected values
		 * @param ratio Ratio of the size of the training set over the size of the validation set
		 * @note Exception are thrown by the inline constructor of the class
		 */
	def apply[T <: AnyVal](
			xt: XVSeries[T],
			expected: Vector[Int], 
			ratio: Double): OneFoldXValidation[T] = 
		new OneFoldXValidation[T](xt, expected, ratio)
		
		/**
		 * Constructor for OneFoldXValidation class using the observation, expected values and
		 * the ratio of training set size and validation set size as arguments
		 * @tparam T type of element of data to be processed 
		 * @param xt Time series or data set of observed features of type Array[Array[T]]
		 * @param expected labels or expected values
		 * @param ratio Ratio of the size of the training set over the size of the validation set
		 * @note Exception are thrown by the inline constructor of the class
		 */
	def apply[T <: AnyVal](
			xt: Array[Array[T]],
			expected: Vector[Int], 
			ratio: Double): OneFoldXValidation[T] = 
		new OneFoldXValidation[T](xt.toVector, expected, ratio)

		/**
		 * Implicit conversion to Try
		 */
	implicit def oneFoldValidation2Try[T <: AnyVal](
			validationFold: OneFoldXValidation[T]): Try[OneFoldXValidation[T]] = Try(validationFold)

		
		
	private def check[T](xt: XVSeries[T], expected: Vector[Int], ratio: Double): Unit = {
		require(xt.size == expected.size, 
			s"OneFoldXValidation found  xt.size =${xt.size} !=  expected.size ${expected.size}")
		require( ratio > 0.1 && ratio < 0.9, 
			s"OneFoldXValidation found ratio = $ratio required 0.1 < ratio < 0.9")
  }
}


// ----------------------  EOF --------------------------